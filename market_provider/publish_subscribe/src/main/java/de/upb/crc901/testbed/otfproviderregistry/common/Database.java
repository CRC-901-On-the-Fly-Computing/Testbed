package de.upb.crc901.testbed.otfproviderregistry.common;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import de.upb.crc901.testbed.otfproviderregistry.Domain;
import de.upb.crc901.testbed.otfproviderregistry.Subject;

/**
 * A data structure storing all OTFProviders and domains.
 * 
 * @author Michael
 *
 */
public class Database {
	private Map<Domain, List<Tuple<String, Subject>>> table = new HashMap<>();
	private List<Domain> domains = new ArrayList<>();

	public void addDomain(Domain domain) {
		if (table.get(domain) == null) {
			table.put(domain, new ArrayList<>());
			domains.add(domain);
		} else
			System.out.println("Warning: Received addDomain for the same domain multiple times.");
	}

	public void removeDomain(Domain domain) {
		if (table.get(domain) != null) {
			// Delete domain from table:
			table.remove(domain);
			domains.remove(domain);
		} else
			System.out.println("Warning: Received removeDomain for a non-existing domain.");
	}

	public List<Domain> getDomains() {
		return domains;
	}

	public Domain getDomain(String name) {
		for (Domain d : domains) {
			if (d.getName().equals(name))
				return d;
		}
		return null;
	}

	/**
	 * Inserts the given subject to the given domain in this database. Returns true,
	 * if a new line in the table had to be generated by this method.
	 * 
	 * @param subject
	 * @param d
	 * @return
	 */
	public void insert(Subject subject, Domain d) {
		if (table.get(d) != null) {
			if (!this.containsSubject(subject, d)) {
				List<Tuple<String, Subject>> subscribers = table.get(d);
				String l_n = Label.generateLabel(subscribers.size());
				subscribers.add(new Tuple<String, Subject>(l_n, subject));
				this.sortDatabase(d);
			}
		} else
			System.err.println("Error: Received insert for a non-existing domain!");
	}

	/**
	 * Returns the current configuration of the given subject.
	 * 
	 * @param s
	 * @param d
	 * @return
	 */
	public Configuration getConfiguration(Subject s, Domain d) {
		if (table.get(d) != null) {
			if (!this.containsSubject(s, d))
				return new Configuration(null, null, null);

			// s is stored in database:
			this.sortDatabase(d);
			int index = this.indexOf(s, d);
			if (this.getDatabaseSize(d) == 1)
				return new Configuration(null, this.getLabel(s, d), null);

			// Size > 1:
			Tuple<String, Subject> left = null;
			Tuple<String, Subject> right = null;
			if (index == 0)
				left = this.getTuple(getDatabaseSize(d) - 1, d);
			else
				left = this.getTuple(index - 1, d);
			if (index == getDatabaseSize(d) - 1)
				right = this.getTuple(0, d);
			else
				right = this.getTuple(index + 1, d);

			String label = this.getLabel(s, d);
			return new Configuration(left, label, right);
		} else
			return new Configuration(null, null, null);
	}

	public void sortDatabase(Domain d) {
		table.get(d).sort(new Comparator<Tuple<String, Subject>>() {
			@Override
			public int compare(Tuple<String, Subject> arg0, Tuple<String, Subject> arg1) {
				float v0 = Label.convertLabelToFloat(arg0.x);
				float v1 = Label.convertLabelToFloat(arg1.x);
				return v0 < v1 ? -1 : (v0 > v1 ? 1 : 0);
			}
		});
	}

	/**
	 * Returns the position of the tuple with value s in this database or -1 if s is
	 * not stored here.
	 * 
	 * @param s
	 * @param d
	 * @return
	 */
	public int indexOf(Subject s, Domain d) {
		for (int i = 0; i < table.get(d).size(); i++) {
			Tuple<String, Subject> t = table.get(d).get(i);
			if (t.y == s)
				return i;
		}
		return -1;
	}

	/**
	 * Returns just a copy, not the actual tuple!
	 * 
	 * @param s
	 * @param d
	 * @return
	 */
	public Tuple<String, Subject> getTuple(Subject s, Domain d) {
		for (Tuple<String, Subject> t : table.get(d))
			if (t.y == s)
				return new Tuple<String, Subject>(t.x, t.y);

		return null;
	}

	/**
	 * Returns just a copy, not the actual tuple!
	 * 
	 * @param index
	 * @param d
	 * @return
	 */
	public Tuple<String, Subject> getTuple(int index, Domain d) {
		Tuple<String, Subject> t = table.get(d).get(index);
		return new Tuple<String, Subject>(t.x, t.y);
	}

	public String getLabel(Subject s, Domain d) {
		for (Tuple<String, Subject> t : table.get(d))
			if (t.y == s)
				return t.x;

		return null;
	}

	public Subject getSubject(String label, Domain domain) {
		for (Tuple<String, Subject> t : table.get(domain))
			if (t.x.equals(label))
				return t.y;

		return null;
	}

	/**
	 * Returns the subscriber of the given domain with label l(i) or null, if no
	 * such subscriber exists in the database.
	 * 
	 * @param i
	 * @param domain
	 * @return
	 */
	public Subject getSubjectAtIndex(int i, Domain domain) {
		String label = Label.generateLabel(i);
		for (Tuple<String, Subject> t : table.get(domain))
			if (t.x.equals(label))
				return t.y;

		return null;
	}

	/**
	 * Returns the overall number of subscribers stored in this database.
	 * 
	 * @param d
	 * 
	 * @return
	 */
	public int getDatabaseSize(Domain d) {
		if (table.get(d) == null)
			return 0;
		return table.get(d).size();
	}

	public List<Tuple<String, Subject>> getSubscribersForDomain(Domain domain) {
		List<Tuple<String, Subject>> sub = new ArrayList<>();
		for (Tuple<String, Subject> t : table.get(domain))
			if (!sub.contains(t))
				sub.add(t);
		return sub;
	}

	/**
	 * Returns true, if the given subject is already stored in the given domain and
	 * false otherwise. Assume d exists in this database when calling this method!
	 * 
	 * @param s
	 * @param d
	 * @return
	 */
	public boolean containsSubject(Subject s, Domain d) {
		for (Tuple<String, Subject> t : table.get(d))
			if (t.y == s)
				return true;

		return false;
	}

	/**
	 * Returns true, if this database has stored the given subject in at least one
	 * domain.
	 * 
	 * @param subject
	 * @return
	 */
	public boolean containsSubject(Subject subject) {
		for (Domain d : table.keySet())
			for (Tuple<String, Subject> t : table.get(d))
				if (t.y == subject)
					return true;

		return false;
	}

	/**
	 * Changes the label for the given subject.
	 * 
	 * @param w
	 * @param domain
	 * @param x
	 */
	public void changeLabel(Subject w, String label, Domain domain) {
		for (Tuple<String, Subject> t : table.get(domain))
			if (t.y == w) {
				t.x = label;
			}
		this.sortDatabase(domain);
	}

	/**
	 * Removes the given tuple from the database.
	 * 
	 * @param tuple
	 * @param domain
	 */
	public void removeTuple(Tuple<String, Subject> tuple, Domain domain) {
		Tuple<String, Subject> rem = null;
		for (Tuple<String, Subject> t : table.get(domain))
			if (t.x.equals(tuple.x) && t.y == tuple.y)
				rem = t;

		if (rem != null) {
			table.get(domain).remove(rem);
			this.sortDatabase(domain);
		}
	}
}